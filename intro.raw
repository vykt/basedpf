OBJECTIVES

-background of problem V
-reason for choice of project V
-identify beneficiaries V
-state objectives V
-broadly outline methods & work plan V
-changes in goals throughout project


CONTENT

 --- background
Intelligence agencies rely on a collection of surveillance capabilities to effectively perform their operations. Rootkits are of the most comprehensive tools available for surveillance, with their functionality extending beyond surveillance to encompass disruption of adversary operations and command-and-control (C&C) capabilities.

Traditional Linux rootkits operate as out-of-tree kernel modules. While this approach permits the rootkit with the same set of capabilities as the core kernel itself, it comes with a very substantial set of limitations.

Irrespective of whether the adversary utilises a distribution or a proprietary configuration of the kernel, the internal structure of said kernels can vary subtantially even between minor updates. The rootkit itself must be compiled against a definite set of kernel sources that progressively become outdated as deployment of the rootkit continues. Despite the various mitigations that may be employed on behalf of the rootkit authors, function pointers and various other offsets will eventually point to incorrect addresses with often devastating results. Kernel panic is very likely, which itself prompts investigation and likely detection of compromise.

The current system is inherently unsafe at every stage, stemming from the C philosophy of entrusting the programmer with memory management and the limited load-time checking performed by the kernel. While this approach justifiably remains dominant, there are select cases where a different system can be employed to provide rootkit capabilities at a fraction of the risk.


The extended Berkeley Packet Filter (eBPF) is a much safer system for extending the behaviour of the kernel. eBPF accepts eBPF programs consisting of eBPF bytecode from userspace. Said programs are safety checked by the eBPF verifier before being just-in-time (JIT) compiled into native instructions and inserted into kernelspace memory. Loaded eBPF programs may then be attached to kprobes, tracepoints, sockets and more.

More importantly, eBPF programs must utilise eBPF helper functions present in the kernel for all external communication with the kernel and userspace. On an eBPF enabled kernel, all failure prone components are updated with each kernel update. The resulting system is much more reliable but less powerful. As will be explored, the eBPF helper functions are more than sufficient for implementing a sophisticated rootkit.

A more severe limitation of eBPF rootkits is their vulnerability to signature scans. Current architecture of eBPF does not permit decryption or mutation to be applied to the eBPF programs once they are loaded in the kernel. Should a signature of the rootkit become publically available, adversaries will be able to scan their kernel (via /dev/kmem) for a match. This has the potential to jeopardise intelligence operations should a C&C uninstall message fail to be processed.


 --- objectives
This project will aim to explore the viability of bytecode mutation of eBPF programs in userspace for the purpose of changing the resulting signatures present in the kernel. To provide a more complete solution, strategies for hiding the mutator itself will also be covered. To minimise the risk of abuse, no offensive capabilities will be designed or implemented, with all research focus on defensive measures.


1)  Implement a mutation algorithm capable of outputting eBPF bytecode that when compiled
    produces:

        -Functional native instructions
        
        -Native instructions that vary enough to make conventional signatures ineffective

    Success measures:

        -Does the eBPF program still run as expected? If it can't be executed, can it 
         be proven that the eBPF program would execute as expected?

        -When taking hashes of the mutated output, how common are collisions?


2)  Design a new system for deployment of eBPF programs that carries out bytecode 
    mutation. Implement critical components.

    Success measures:

        -What does the target system need to have present besides an eBPF enabled 
         kernel?

        -Do all the components of the deployment system work together in theory? 
         Can they be practically implemented?

        -Is the deployment system realistic? Is it too cumbersome to be used 
         in practice? Is this system devoid of needless complexity?

        -Does the implementation of critical components function correctly?



 --- reason for choice of project
eBPF has seen consistent growth in popularity and utilisation, especially since it's adoption into the mainline Linux source tree in 2011. Despite this growth the tooling to utilise eBPF remains fragmented, inflexible and on occasion - unreliable. It can be speculated that as a result of the general unavailability of sophisticated eBPF tooling, instrusion detection systems (IDS) are not ready to deal with advanced eBPF threats. Bytecode mutation is typically seen in compiled languages or mature VM ecosystems like Java. Completion of this project yields a formiddable edge over existing IDS systems, especially when considering anti-virus (AV) scan ruleset ecosystems sysadmins may rely on.


--- beneficiaries
1) Intelligence agenices

Intelligence agencies are a primary beneficiary. While they possess a multitude of backdoors and zero-days at their disposal, the work produced by this research project should be capable of providing a starting point for developing a practical eBPF rootkit. Container orchestration services like kubernetes utilise eBPF as part of their core functionality. eBPF rootkits may be utilised on adversary web services utilising kubernetes. The recently shutdown BreachForums is one example of a potential target.


2) The open source community

Security applications of eBPF have increasingly garnered attention and are a subject of ongoing debate. There exist numerous examples of eBPF's malicious capabilities, with the more notable examples being pathtofile's bad-bpf DEFCON presentation and h3xduck's sophisticated TripleCross rootkit implementation. Defensive use cases of eBPF are even more plentiful, redcanary's kernel auditing eBPF utilities being one example. It's hoped that this project contributes to the discussion and steers the lead engineers of eBPF towards reasonable design decisions.


3) Cilium

"Cilium is an open source project to provide networking, security, and observability for cloud native environments such as Kubernetes clusters and other container orchestration platforms." 

With industry hopefully taking risk assessment seriously, this project should contribute to the discussion regarding the safety of eBPF enabled kernels.


4) The researcher

The researcher gets an opportunity to practically study machine code mutation, Linux kernel programming and compromise of userspace using kernel modules. This aids the researcher greatly in expanding their process exploitation library.


 --- work plan & methods
The work of this project is divided into two distinct phases. The first phase explores the various eBPF deployment toolchains and the benefits and drawbacks they offer within the context of rootkit deployment. The second stage explores eBPF bytecode mutation methods that are applicable to the chosen deployment method.

Once both the deployment and mutation approaches have been determined, implementation of a proof of concept rootkit will take place. The final deliverable will serve as an excellent base that can be extended with additional capabilities to produce a deployment ready solution. For examples of these additional capabilities, refer to pathtofile's bad-bpf repository or h3xduck's TripleCross rootkit.

Implementation will utilise the Agile methodology to maximise the return on time investment and provide the necessary flexibility necessitated by eBPF's incomplete documentation and the researcher's inexperience with kernel development.
