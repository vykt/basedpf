OBJECTIVES

-state of topic:
    >theory
    >practice

-constraints on work
-comparable projects
-projects ideas borrowed from
-le literature

TODO

-Diamorphine rootkit comparison


REFERENCES

X0 https://github.com/h3xduck/TripleCross
X1 https://github.com/Gui774ume/ebpfkit
X2 https://github.com/pathtofile/badbpf
X3 https://github.com/vykt/libpwu
X4 https://man7.org/linux/man-pages/man2/getdents.2.html
X5 https://docs.kernel.org/filesystems/proc.html


CONTENT

 --- ebpf theory
For the reader's convenience this paragraph will provide a short summary of eBPF capabilities before delving into their implications. eBPF programs operate as kernel function hooks; they may be attached to kprobes, tracepoints, sockets and other kernel functions. eBPF maps are data structures that reside in kernel memory and allow eBPF programs to communicate with userspace and to maintain state between execution instances. The eBPF verifier enforces a 1,000,000 instruction limit on eBPF programs - if it is deemed that an eBPF program may execute more than 1,000,000 instructions before returning, it will be rejected. Finally, eBPF is not turing-complete.

The most sophisticated and comprehensive evaluation of offensive capabilities of eBPF can be found in "An analysis of offensive capabilities of eBPF and implementation of a rootkit" by M. S. Bajo (2022). The paper succinctly summarises a wide range of implementation details of eBPF, the Linux kernel, and the greater Linux environment through a security perspective. The paper showcases how eBPF helper functions can be used to achieve similar functionality to traditional rootkits like Diamorphine despite operating under stricter restrictions.

One of the most important restrictions identified by M. S. Bajo is the inability for eBPF programs to arbitrarily read, write and execute kernel memory. The kernel attempts to place similar restrictions on the 'bpf_probe_write_user()' helper that attempts to write to arbitrary userspace memory. M. S. Bajo identifies that this helper will fail if attempting to write to virtual pages marked r-x, as is common with .text segments of ELF executables. M. S. Bajo concludes here that execution hijacking should be performed by hijacking execve calls or modifying the writeable .got (global offset table) section of ELF executables. This is only partially correct, as eBPF programs may be temporarily injected to hook syscalls of a target process and change them to call mprotect(), which can then add write permissions to .text segments. For a non-eBPF implementaion of this, see K. Nikanchyk's Libpwu (2023).

Due to the many restrictions placed on eBPF, only a userspace mutator is feasible. Both M. S. Bajo's and K. Nikanchyk's methods of execution hijacking can allow the mutator to reside inside an existing process. For example, injected code may be registered as a signal handler, with the loader intentionally triggering exceptions in the target process to execute the mutator. All of this adds complexity and potential failure points. Consider unexpected process termination or updates changing the structure of the target process for example. This undermines the primary benefit of eBPF - reliability.

M. S. Bajo's analysis of eBPF's offensive capabilities extends equally to defensive capabilities. As will be explored later in this document, bpf_override_return() and especially bpf_kprobe_user_write() can be used to modify syscall returns which can render userspace attempts at monitoring completely ineffective. In order to maximise reliability, componentns of the adversary system should be utilised as intended as much as possible. it is therefore likely more reasonable to make the mutator its own process and hide it with eBPF.

This concludes the extent of academic literature focusing on eBPF's security capabilities. The majority of the research is focused on extending eBPF functionality or applying it in network filtering scenarios for which eBPF is more aptly suited.


 --- ebpf practice
There exist two sophisticated, holistic eBPF rootkit implementations. The first is the aforemention TripleCross rootkit developed by M. S. Bajo (X0). The other is ebpfkit, presented at BlackHat 2021 by G. Fournier, S. Afchain and S. Baubeau (X1). Implementations of individual rootkit features are more plentiful, with pathtofile's bad-bpf being a prominent example that was presented at DEFCON 29 [X2]. These implementations provide the practical counterpart to the theory covered in M. S. Bajo's work, with ebpfkit in particular often going beyond what is academically documented to implement advanced capabilities.

pathtofile's PID concealing eBPF program is arguably the most broadly useful due to its multifaceted nature. It works by hooking the getdents64 system call and saving the buffer passed to the kernel in an eBPF map on syscall entry. On syscall exit, the buffer will be populated with linux_dirent64 structures (X4). The eBPF program will fetch the buffer and iterate through these structures until it encounters its target process ID located in the d_name field. The d_name field of the linux_dirent64 structure stores a variable length string, necessitating the use of the d_reclen field to store the total size of the structure, which varies from instance to instance. By extending the d_reclen field of the entry before the matching entry, it is possible to hide the matching entry. It is important to note that the hidden directory entries will still technically be present in the buffer, however software that processes these buffers, typically libc, will use d_reclen fields to determine the location of entries and will therefore skip the matching entry. Given libc is linked into every process on Linux for purposes like this, this project deems it sufficient.

[DIAGRAM OF getdents64]

Why exactly are linux_dirent64 structures used to hide processes? On Linux, process information is exposed via the proc pseudo filesystem (X5). Utilities like ps obtain a list of processes by iterating through the directory entries in /proc. What this ultimately means is pathtofile's PID concealing eBPF program can be utilised to hide both the loader and mutator processes as well as all rootkit related files on the filesystem. This document deems this a critical component; re-implementation and extension of this eBPF program will be covered further into the document.

The remaining implementations have been observed for inspiration but have not been sampled directly. The remaining components will instead be designed from the ground up following fundamental eBPF principles.


 --- ebpf reliability
A brief contextualisation of eBPF reliability is due to justify the importance of this project. Software reliability is elegantly defined by H. & M. Phan as "the probability of failure-free operation of software for a specified period of time under specified conditions" (05). Phan & Phan's literature review identifies numerous software reliability models that may be applied to this project. Said models can be split into two categories. The first are deterministic models that trace execution flow and perform mathematical analysis on categorised instructions and data. The second are probabilistic models that apply mathematical models to the outcome of a fuzzing run.

Very importantly, Phan & Phan's literary review states that all of the models work based off of assumptions (yes, so do all models, but the emphasis placed by the paper may be interpreted to mean that these assumptions are less 'reliable' than is typical). Given both the age of these models and the unique circumstances that this project operates in, namely a changing environment in the form of a changing kernel structure, it is very possible that these models may be unfit for purpose here. The researcher lacks the knowledge and time to find a model that is more appropriate for these circumstances.

Difficulty of correctly utilising these models is also substantial. Probabilistic models require kernel fuzzing and application of advanced statistics which are by no means trivial tasks. Deterministic models are more sensitive to unexpected changes and are inherently not designed to handle random events like kernel structural changes (it's in the name!).

Therefore while using one of these models proves too challenging, its believed that a simple architectural comparison between traditional rootkits and eBPF rootkits, together with an understanding of kernel architecture should sufficiently suggest that eBPF rootkits should be expected to be more reliable.

To begin it is important to consider what precisely changes in the kernel.

-kernel memory divided into sections]


[REFERENCE THE BOOK ON KERNEL PROGRAMMING, THE PART ON KERNEL MEMORY]


-Bug counting model -> doesnt account for software changing over time
